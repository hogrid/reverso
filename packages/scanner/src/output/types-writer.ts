/**
 * TypeScript types output writer.
 */

import { existsSync } from 'node:fs';
import { mkdir, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import {
  type FieldSchema,
  type FieldType,
  type PageSchema,
  type ProjectSchema,
  type SectionSchema,
  TYPES_FILE_NAME,
  camelCase,
  pascalCase,
} from '@reverso/core';

/**
 * Options for writing TypeScript types.
 */
export interface TypesWriterOptions {
  /** Output directory */
  outputDir: string;
  /** Include JSDoc comments (default: true) */
  includeComments?: boolean;
  /** Export format: 'named' | 'default' (default: 'named') */
  exportFormat?: 'named' | 'default';
}

/**
 * Generate TypeScript type definitions from a schema.
 */
export function generateTypeDefinitions(
  schema: ProjectSchema,
  options: TypesWriterOptions = { outputDir: '' }
): string {
  const lines: string[] = [];
  const includeComments = options.includeComments !== false;

  // Header
  lines.push('/**');
  lines.push(' * Auto-generated types from Reverso CMS schema.');
  lines.push(' * Do not edit this file manually.');
  lines.push(` * Generated at: ${schema.generatedAt}`);
  lines.push(' */');
  lines.push('');

  // Import base types
  lines.push('import type {');
  lines.push('  ImageValue,');
  lines.push('  FileValue,');
  lines.push('  GalleryValue,');
  lines.push('  VideoValue,');
  lines.push('  AudioValue,');
  lines.push('  OEmbedValue,');
  lines.push('  LinkValue,');
  lines.push('  MapValue,');
  lines.push('  BlocksValue,');
  lines.push('  RelationValue,');
  lines.push('  TaxonomyValue,');
  lines.push('  UserValue,');
  lines.push('  CodeValue,');
  lines.push("} from '@reverso/core';");
  lines.push('');

  // Generate types for each page
  for (const page of schema.pages) {
    lines.push(...generatePageTypes(page, includeComments));
    lines.push('');
  }

  // Generate root content type
  lines.push(generateRootType(schema, includeComments));

  return lines.join('\n');
}

/**
 * Generate types for a single page.
 */
function generatePageTypes(page: PageSchema, includeComments: boolean): string[] {
  const lines: string[] = [];
  const pageTypeName = `${pascalCase(page.slug)}Content`;

  if (includeComments) {
    lines.push(`/** Content for the ${page.name} page */`);
  }
  lines.push(`export interface ${pageTypeName} {`);

  for (const section of page.sections) {
    const sectionTypeName = pascalCase(page.slug) + pascalCase(section.slug);

    if (includeComments && section.isRepeater) {
      lines.push(`  /** ${section.name} (repeater) */`);
    } else if (includeComments) {
      lines.push(`  /** ${section.name} */`);
    }

    if (section.isRepeater) {
      lines.push(`  ${camelCase(section.slug)}: ${sectionTypeName}Item[];`);
    } else {
      lines.push(`  ${camelCase(section.slug)}: ${sectionTypeName};`);
    }
  }

  lines.push('}');
  lines.push('');

  // Generate section types
  for (const section of page.sections) {
    lines.push(...generateSectionTypes(page, section, includeComments));
  }

  return lines;
}

/**
 * Generate types for a single section.
 */
function generateSectionTypes(
  page: PageSchema,
  section: SectionSchema,
  includeComments: boolean
): string[] {
  const lines: string[] = [];
  const sectionTypeName = pascalCase(page.slug) + pascalCase(section.slug);
  const typeName = section.isRepeater ? `${sectionTypeName}Item` : sectionTypeName;

  if (includeComments) {
    lines.push(`/** ${section.name} ${section.isRepeater ? 'item' : 'section'} */`);
  }
  lines.push(`export interface ${typeName} {`);

  // Get fields for this section (filter out repeater placeholder)
  const fields = section.fields.filter((f) => {
    const parts = f.path.split('.');
    return !parts.includes('$') || parts[parts.length - 1] !== '$';
  });

  for (const field of fields) {
    const fieldName = getFieldName(field);
    const fieldType = getTypeScriptType(field);
    const isOptional = !field.required;

    if (includeComments && field.label) {
      lines.push(`  /** ${field.label} */`);
    }

    lines.push(`  ${camelCase(fieldName)}${isOptional ? '?' : ''}: ${fieldType};`);
  }

  lines.push('}');
  lines.push('');

  return lines;
}

/**
 * Get the field name from a field schema.
 */
function getFieldName(field: FieldSchema): string {
  const parts = field.path.split('.');

  // Skip the repeater placeholder if present
  const filtered = parts.filter((p) => p !== '$');

  // Return the last part
  return filtered[filtered.length - 1] ?? 'unknown';
}

/**
 * Map Reverso field types to TypeScript types.
 */
function getTypeScriptType(field: FieldSchema): string {
  const typeMap: Record<FieldType, string> = {
    // Text inputs
    text: 'string',
    textarea: 'string',
    number: 'number',
    range: 'number',
    email: 'string',
    url: 'string',
    phone: 'string',
    // Rich content
    wysiwyg: 'string',
    markdown: 'string',
    code: 'CodeValue',
    blocks: 'BlocksValue',
    // Selection
    select: 'string',
    multiselect: 'string[]',
    checkbox: 'boolean',
    checkboxgroup: 'string[]',
    radio: 'string',
    boolean: 'boolean',
    // Media
    image: 'ImageValue',
    file: 'FileValue',
    gallery: 'GalleryValue',
    video: 'VideoValue',
    audio: 'AudioValue',
    oembed: 'OEmbedValue',
    // Date/Time
    date: 'string',
    datetime: 'string',
    time: 'string',
    // Relationships
    relation: field.multiple ? 'RelationValue[]' : 'RelationValue',
    taxonomy: field.multiple ? 'TaxonomyValue[]' : 'TaxonomyValue',
    link: 'LinkValue',
    pagelink: 'string',
    user: 'UserValue',
    // Advanced
    color: 'string',
    map: 'MapValue',
    repeater: 'unknown[]', // Will be replaced with actual type
    group: 'Record<string, unknown>',
    flexible: 'unknown[]',
    // UI helpers (no data)
    message: 'never',
    tab: 'never',
    accordion: 'never',
    buttongroup: 'string',
  };

  return typeMap[field.type] ?? 'unknown';
}

/**
 * Generate the root content type that combines all pages.
 */
function generateRootType(schema: ProjectSchema, includeComments: boolean): string {
  const lines: string[] = [];

  if (includeComments) {
    lines.push('/** All content types */');
  }
  lines.push('export interface ReversoContent {');

  for (const page of schema.pages) {
    const pageTypeName = `${pascalCase(page.slug)}Content`;
    if (includeComments) {
      lines.push(`  /** ${page.name} */`);
    }
    lines.push(`  ${camelCase(page.slug)}: ${pageTypeName};`);
  }

  lines.push('}');

  return lines.join('\n');
}

/**
 * Write TypeScript types to a file.
 */
export async function writeTypesFile(
  schema: ProjectSchema,
  options: TypesWriterOptions
): Promise<string> {
  const outputPath = join(options.outputDir, TYPES_FILE_NAME);

  // Ensure output directory exists
  if (!existsSync(options.outputDir)) {
    await mkdir(options.outputDir, { recursive: true });
  }

  // Generate type definitions
  const content = generateTypeDefinitions(schema, options);

  // Write file
  await writeFile(outputPath, content, 'utf-8');

  return outputPath;
}
